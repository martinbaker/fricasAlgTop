From d6dbd36370ce349b313d86c0d4bf1196ddeef30e Mon Sep 17 00:00:00 2001
From: martinbaker <ax87438@martinb.com>
Date: Mon, 14 Nov 2016 17:32:04 +0000
Subject: [PATCH 8/8] add coerce from PermutationGroup to GroupPresentation

---
 src/algebra/permgrps.spad | 157 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 157 insertions(+)

diff --git a/src/algebra/permgrps.spad b/src/algebra/permgrps.spad
index 2bc42d9..1760cf4 100644
--- a/src/algebra/permgrps.spad
+++ b/src/algebra/permgrps.spad
@@ -39,6 +39,7 @@ PermutationGroup(S : SetCategory) : public == private where
              gpbase : L NNI, orbs : V REC, mp : L S, wd : L L NNI)
   REC3 ==> Record(elt : V NNI, lst : L NNI)
   REC4 ==> Record(bool : B, lst : L NNI)
+  WORD ==> L Record(node : NNI, edge : Integer)
 
   public ==> SetCategory with
 
@@ -136,6 +137,9 @@ PermutationGroup(S : SetCategory) : public == private where
       ++ pointList(gp) should be local but conditional
     perm_to_vec : (L S, PERM S, NNI) -> V NNI
       ++ perm_to_vec(supp, p, degree) should be local but conditional
+    coerce : (a:%) -> GroupPresentation
+      ++ construct a presentation
+
   private ==> add
 
     -- representation of the object:
@@ -847,6 +851,159 @@ PermutationGroup(S : SetCategory) : public == private where
     initializeGroupForWordProblem(gp) ==
         initializeGroupForWordProblem(gp, 0, 1)
 
+    -- Local function to construct a list of all elements.
+    -- Each time we find an element we add it here.
+    -- I don't like calling by reference because its not 'functional' and
+    -- it obscures the meaning but I did it to avoid messy passing around of
+    -- return values.
+    concatEleIfNew(allEleR : Reference L PERM S, newEle : PERM S) : L PERM S ==
+        allEle : L PERM S := deref(allEleR)
+        --print("concatEleIfNew allEle=" << allEle << " newEle=" << newEle)
+        if member?(newEle,allEle) then return allEle
+        allEle := concat(allEle, newEle)
+        setref(allEleR,allEle)
+        allEle
+
+    -- local function to construct tree recursively until loop detected.
+    -- gs holds permutation for each generator.
+    -- gInvs holds permutation for inverse of each generator.
+    -- allEleR holds reference to permutation for every element.
+    --   I don't like calling by reference because its not 'functional' and
+    --   it obscures the meaning but I did it to avoid messy passing around of
+    --   return values.
+    -- ele holds permutation for current element.
+    -- parent holds parent of this node.
+    -- pathElements holds path so far as list of elements (nodes)
+    -- loopBreaker holds recursion depth to prevent infinite recursion
+    constructTree(gs : L PERM S,gInvs : L PERM S,allEleR : Reference L PERM S,_
+                 ele : PERM S, parent : Tree PERM S ,_
+                 pathElements : L PERM S,loopBreaker : NNI) : Tree PERM S ==
+        x<<y ==> hconcat(x::OutputForm, y::OutputForm)
+        if loopBreaker > 10000 then error "can't create groupPresentation - too big"
+        --print("constructTree gs=" << gs << " ele=" << ele << " parent=" << parent _
+        --        << " pathWord=" << pathWord << " pathElements=" << pathElements)
+        children : List Tree PERM S := []
+        -- Nodes in tree should either be leaf node or have branches for
+        -- every generator.
+        if member?(ele,pathElements) then
+          -- loop detected so this is a leaf node.
+          leaf: Tree PERM S:= tree(ele)
+          return leaf
+        -- not a leaf so generate child for each generator
+        for g in gs for ng in 1..(#gs) repeat
+          newEle : PERM S := ele*g
+          concatEleIfNew(allEleR, newEle)
+          newPathElements: L PERM S := concat(pathElements,ele)
+          subTree: Tree PERM S:= constructTree(gs,gInvs,allEleR, newEle, parent,_
+                                 newPathElements,loopBreaker+1)
+          --if loopBreaker=0 then print("constructTree A ng=" << ng << " subTree=" << subTree)
+          children := concat(children,subTree)
+        -- also generate child for each inverse generator
+        for gInv in gInvs for ng in 1..(#gInvs) repeat
+          newEle : PERM S := ele*gInv
+          concatEleIfNew(allEleR, newEle)
+          newPathElements: L PERM S := concat(pathElements,ele)
+          subTree: Tree PERM S:= constructTree(gs,gInvs,allEleR, newEle, parent,_
+                                 newPathElements,loopBreaker+1)
+          children := concat(children,subTree)
+          --if loopBreaker=0 then print("constructTree B ng=" << -ng << " subTree=" << subTree)
+        tree(ele,children)
+
+    -- local function to map permutation tree to index tree.
+    -- tr holds tree of permutations
+    -- numGens holds the number of (non-inverted) generators
+    -- allEle holds list of all elements as permutations, used to indexify
+    -- word holds sequence (List) of elements as both node and generator sequence.
+    mapTree(tr : Tree PERM S,numGens : NNI,allEle : L PERM S,word : WORD) : Tree WORD ==
+        if empty?(tr) then return empty()
+        v : PERM S := value(tr)
+        integ : Integer := position(v,allEle)
+        if integ<0 then return empty()
+        i : NNI := integ pretend NNI
+        me : Record(node : NNI, edge : Integer) := [i,0]
+        w := concat(word,me)
+        if leaf?(tr) then return tree(w)
+        chas:List Tree PERM S := children(tr)
+        chbs:List Tree WORD := []$(List Tree WORD)
+        --first map for positive generators
+        for cha in chas for chn in 1..(#chas) repeat
+          -- chn gives number of generators + inverse generators
+          -- we convert this to a positive number for generators and
+          -- a negative number for inverses.
+          chni : Integer := chn
+          if chni > numGens then
+              chni := numGens-chni
+          me := [i,chni]
+          chb : Tree WORD := mapTree(cha,numGens,allEle,concat(word,me))
+          chbs := concat(chbs,chb)
+        tree(w,chbs)
+
+    -- local function to map index tree to list of paths.
+    calculatePaths(tr : Tree WORD) : L WORD ==
+        x<<y ==> hconcat(x::OutputForm, y::OutputForm)
+        paths : L WORD := []$(L WORD)
+        if empty?(tr) then return paths
+        if leaf?(tr) then
+            w:WORD := value(tr)
+            --print("calculatePaths word=" << w)
+            return [w]
+        chs:List Tree WORD := children(tr)
+        for ch in chs repeat
+            newPaths : L WORD := calculatePaths(ch)
+            paths := concat(paths,newPaths)
+        paths
+
+    -- local function to map paths to loops .
+    calculateLoops(paths : L WORD) : L L Integer ==
+        x<<y ==> hconcat(x::OutputForm, y::OutputForm)
+        loops : L L Integer := []
+        for p in paths repeat
+          if #p < 2 then break
+          lastNode : NNI := p.last.node
+          found : Boolean := false
+          loop : L Integer := []
+          for e in p repeat
+              node1 : NNI := e.node
+              edge1 : Integer := e.edge
+              if node1 = lastNode then found := true
+              if found and edge1 ~= 0 then
+                  loop := concat(loop,edge1)
+          loops := concat(loops,loop)
+        loops
+
+    -- construct a presentation
+    coerce(a:%) : GroupPresentation ==
+        x<<y ==> hconcat(x::OutputForm, y::OutputForm)
+        t:Tree PERM S := empty()
+        -- gs will hold generators
+        gs : L PERM S := generators(a)
+        -- gInvs will hold inverses of generators
+        gInvs : L PERM S := [inv(g) for g in gs]
+        -- elementIndex will list all permutations so we can refer to them by the
+        -- position in this list.
+        -- We start by preloading the list with identity and generators.
+        elementIndex : L PERM S := [1$(PERM S)]
+        elementIndexR : Reference L PERM S := ref(elementIndex)
+        for g in gs repeat
+            concatEleIfNew(elementIndexR,g)
+        for gInv in gInvs repeat
+            concatEleIfNew(elementIndexR,gInv)
+        t := constructTree(gs,gInvs,elementIndexR,1$(PERM S),t,[]$(L PERM S),0)
+        --print(message "groupPresentation tree=" << t)
+        elementIndex : L PERM S := deref(elementIndexR)
+        --print(message "groupPresentation elements=" << elementIndex)
+        -- indexify element list.
+        emptyWord : WORD := []$WORD
+        itr:Tree WORD := mapTree(t,#gs,elementIndex,emptyWord)
+        --print(message "groupPresentation itr=" << itr)
+        relators: L WORD := calculatePaths(itr)
+        --print(message "groupPresentation relators=" << relators)
+        loops: L L Integer := calculateLoops(relators)
+        --print(message "groupPresentation loops=" << loops)
+        gens : List(NNI) := [x for x in 1..(#gs)]
+        rels : List(List(Integer)) := loops
+        simplify(groupPresentation(gens,rels))
+
 )abbrev package PGE PermutationGroupExamples
 ++ Authors: M. Weller, G. Schneider, J. Grabmeier
 ++ Date Created: 20 February 1990
-- 
2.1.4

